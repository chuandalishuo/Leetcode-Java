Leetcode-java
=============
Author: Shuo Li

Solutions of leetcode coding problems

0. Easy

        3. 4Sum (夹逼,剪枝)
        4. Add Binary (进位)
        5. Add Two Numbers (进位)
        6. Anagram (HashMap, String sort)
        7. Balanced Binary Tree (Recursive)
        8. Best Time to Buy and Sell Stock (greedy)
        9. Best Time to Buy and Sell Stock II (greedy)
         . Maximum Subarray (DP)
        11.Binary Tree In order Traversal (Recursive)
        12.Binary Tree Level Order Traversal (Recursive)
        15.Binary Tree post order Traversal (Recursive)
        16.Binary Tree Preorder Traversal (Recursive)
        17.Binary Tree Zigzag Level Order Traversal (Recursive, Collections.reverse(List))
        18.Candy (前后扫描)
        19.Climbing Stairs(DP,斐波那契数列)
        22.Combination Sum II (深搜+目标递减+不断向后搜索+剪枝)
        23.Combinations (深搜+目标递减+不断向后搜索)
        25.Construct Binary Tree from Preorder and Inorder Traversal (same as 24)
        27.Convert Sorted Array to Binary Search Tree(similar as 24, more simple, 递归折半)
1. Need to do more times
    
        1. 3Sum (夹逼,剪枝)
        2. 3Sum Closest (夹逼,剪枝)
        13.Binary Tree Level Order Traversal II(reverse recursive, Collections.reverse(List))
        21.Combination Sum (深搜+目标递减+不断向后搜索+剪枝)
2. Time consuming

        20.Clone Graph(dfs/bfs graph traversal + HashMap mark cloned)
        24.Construct Binary Tree from Inorder and Postorder Traversal(递归，用inorder中左右子树长度确定postorder中左右子树的分割)
3. Difficult
        
        10. Best Time to Buy and Sell Stock III (最大M段子和, 两侧DP)
        14. Binary Tree Maximum Path Sum
        26.Container With Most Water (greedy, 两头夹逼测试每次保证不减，容积取决于短板。夹逼过程还可以剪枝。)
        28.Convert Sorted List to Binary Search Tree (递归折半，全局变量遍历链表)
